---
title: "i-node와 링크, 그리고 리눅스 파일 시스템 구조"
excerpt: "리눅스 개념 중 i-node에 관해 알아봅니다"
categories:
  - Linux
tags:
  - i-node
  - Link
  - File System
toc: true
toc_sticky: true
last_modified_at: 2025-03-26
---

리눅스 수업에서 링크를 배우기 전, `i-node` 라는 개념이 등장했습니다. 
처음 배우는 내용이지만 흥미로웠기 때문에 구글링을 통해 학습했고 그 내용을 정리하고자 합니다. 
파일을 만들고, 삭제하고, 디렉터리를 탐색하고, 심지어 프로그램을 실행할 때도 `i-node`가 핵심적인 역할을 하기 때문에, 
리눅스에서 필수적으로 알아야 하는 개념이라는 생각이 들었습니다. 
이번 포스팅에서는 `i-node`를 중심으로, 디렉터리, 링크(하드링크/심볼릭링크) 개념을 정리해보겠습니다.

---

## 1️⃣ i-node란 무엇일까?

간단히 말해, **i-node는 파일의 메타데이터를 저장하는 자료구조**입니다. 
중요한 사실은, 파일 내용 자체는 저장하지 않습니다. 단지, 파일에 관한 정보만 갖게 되며, 그 내용은 다음과 같습니다:

- 파일의 소유자 (UID)
- 파일의 그룹 (GID)
- 접근 권한 (Permission)
- 파일 크기 (Size)
- 생성/수정/접근 시간 (ctime, mtime, atime)
- 실제 데이터 블록 위치 정보
- 하드링크 개수

> 즉, 리눅스는 파일의 '내용'과 '이름'을 분리해서 관리하며, 파일 이름은 디렉터리에서 관리되고, 파일의 실제 내용은 `i-node`를 통해 찾아갑니다.

---

## 2️⃣ 디렉터리는 어떻게 작동할까?

리눅스에서 **디렉터리는 특수한 파일**로 취급되며, 내부에는 다음과 같은 **엔트리** 목록이 존재합니다:

```css
파일 이름 -> i-node 번호
```

> 예를 들면, `ls -li` 명령어로 파일 정보를 확인하면 i-node 번호가 함께 출력됩니다. 
> 이렇게 디렉터리는 "이름표" 역할을 하며, 이름으로 i-node를 찾아가는 중간 단계입니다.

---

## 3️⃣ 링크의 개념: 하드링크 VS. 심볼릭링크

### 🔹 하드링크

- 같은 i-node 번호를 공유하는 **다른 이름의 파일**
- 원본 파일과 같은 i-node를 참조하므로, 진짜로 "같은 파일"
- 원본을 삭제해도 하드링크가 남아 있으면 파일은 삭제되지 않음

```bash
ln fileA fileAA  # 하드링크 생성
```

> fileA, fileAA는 같은 i-node를 가짐

### 🔹 심볼릭링크

- 다른 파일 경로를 문자열로 저장한 **다른 파일**
- 다른 i-node를 가짐 (파일 내용은 단순히 경로 문자열)
- 원본 파일 삭제 시, 링크는 "끊어진 링크"가 됨

```bash
ln -s fileA fileAA  # 심볼릭링크 생성
```

---

## 4️⃣ i-node 관련 명령어 정리

- ls -li: 파일의 i-node 번호 확인
- stat 파일명: 파일의 i-node 정보 상세 출력
- df -i: 파일 시스템의 i-node 사용량 확인
- find . -inum [번호]: 특정 i-node를 참조하는 파일 찾기

---

## 정리

리눅스 파일 시스템의 핵심은 "이름과 내용의 분리"입니다. 디렉터리 엔트리는 이름만 가지고 있고, 
i-node가 진짜 정보를 갖고 있으며, 링크는 이 구조 위에서 유연한 파일 연결을 가능하게 합니다.



